---
title: PicoCTF 2018 - rsa-madlibs
author: AlphaChaos
date: 2020-11-26 14:00:00 +0000
categories: [PicoCTF_2018]
tags: [basics, picoctf, rsa, beginner]     # TAG names should always be lowercase
---

### Challenge Description

> We ran into some weird puzzles we think may mean something, can you help me solve one? Connect with `nc 2018shell.picoctf.com 40440`

### Challenge Hint

> [RSA info](https://simple.wikipedia.org/wiki/RSA_algorithm)

### Challenge Analysis

So let's look at what information we are given in the challenge.  

For this challenge we've again been given a netcat connection to a remote server that we can communicate with, and also the challenge hint gives us a link to the RSA wikipedia page.

> **Note:** RSA is one of the mostly used cryptographic algorithms and often appears in CTF crypto challenges. Getting a good understand of how RSA works and the various attacks possible against RSA will be key if you want to do well on crypto challenges.

```common
Summary
--------------------------------
remote server  = nc 2018shell.picoctf.com 40440
RSA wiki: https://simple.wikipedia.org/wiki/RSA_algorithm
```

### Challenge Solution

>**Note:** This challenge has lots of steps and is like a walk through tutorial of RSA. It's an excellent challenge to introduce RSA concepts and it's often the challenge I direct new CTF players to when they are asking for help.

So let's connect to the remote server and see what we need to do.

```terminal
$nc 2018shell.picoctf.com 40440
Hello, Welcome to RSA Madlibs
Keeping young children entertained, since, well, nev3r
Tell us how to fill in the blanks, or if it's even possible to do so
Everything, input and output, is decimal, not hex
#### NEW MADLIB ####
q : 93187
p : 94603
##### WE'RE GONNA NEED THE FOLLOWING ####
n
IS THIS POSSIBLE and FEASIBLE? (Y/N):
```

`Question 1:` We've been given the values for p and q and asked is it feasible to get n?

`Answer 1`: `Yes` it is feasible. The RSA algorithm begins by choosing two large prime numbers that are usually called p and q. These two numbers are then multiplied together to give the value n (or modulus).

```terminal
IS THIS POSSIBLE and FEASIBLE? (Y/N):Y
#### TIME TO FILL IN THE MADLIB! ###
n:
```

`Question 2:` We need to work out the value of n.

`Answer 2:` `n = p * q = 93187 * 94603 = 428939761`

```terminal
#### TIME TO FILL IN THE MADLIB! ###
n: 8815769761
YAHHH! That one was a great madlib!!!


#### NEW MADLIB ####
p : 81203
n : 6315400919
##### WE'RE GONNA NEED THE FOLLOWING ####
q
IS THIS POSSIBLE and FEASIBLE? (Y/N):
```

`Question 3:` This time we've been given the values for p and n, and we are asked is it feasible to to calculate q?

`Answer 3:` We've already seen that n=p*q, so we should be easily able to see that q = n/p. So `yes` this is feasible.

```terminal
IS THIS POSSIBLE and FEASIBLE? (Y/N):Y
#### TIME TO FILL IN THE MADLIB! ###
q:
```

`Question 4:` Calculate the value for q

`Answer 4:` q = n/p therefore q = 6315400919 / 81203 = `77773`

```terminal
q: 77773
YAHHH! That one was a great madlib!!!


#### NEW MADLIB ####
e : 3
n : 12738162802910546503821920886905393316386362759567480839428456525224226445173031635306683726182522494910808518920409019414034814409330094245825749680913204566832337704700165993198897029795786969124232138869784626202501366135975223827287812326250577148625360887698930625504334325804587329905617936581116392784684334664204309771430814449606147221349888320403451637882447709796221706470239625292297988766493746209684880843111138170600039888112404411310974758532603998608057008811836384597579147244737606088756299939654265086899096359070667266167754944587948695842171915048619846282873769413489072243477764350071787327913
##### WE'RE GONNA NEED THE FOLLOWING ####
q
p
IS THIS POSSIBLE and FEASIBLE? (Y/N):
```

`Question 5:` This time we've been given the values for e and n, and we're asked is it feasible to find p and q?

`Answer 5`: `No` this is not feasible.

`Answer 5 explained:` This is the core of RSA, given the public key values (n,e) it is not possible to work out the original p and q values that were used to calculate n (remember n=p*q).

Now this doesn't seem right if I gave you the number 187 and asked you for the factors (i.e. what numbers did I multiply together to get a result of 187) you would try each number 1,2,3 etc.. and check if they divided into 187 until you figured out 11 divides into 187, 17 times. So why wouldn't this method work for the bigger number?

Well the answer is yes,it would eventually work. however the amount of time it would take means that none of us would be around to see your computer finally print the result. It just takes too long. You'll notice that the question asked is it feasible, not is it possible. In cryptography we talk about problems being feasible, because most of the cryptography we used today is possible to break but would just take so long, even using all the computing power on the planet, that we say it's infeasible to break them.  

```terminal
##### WE'RE GONNA NEED THE FOLLOWING ####
q
p
IS THIS POSSIBLE and FEASIBLE? (Y/N):n
YAHHH! That one was a great madlib!!!


#### NEW MADLIB ####
q : 78203
p : 79999
##### WE'RE GONNA NEED THE FOLLOWING ####
totient(n)
IS THIS POSSIBLE and FEASIBLE? (Y/N):
```

`Question 6:` Moving on, the next value we're asked if it's feasible to to find is the totient(n).

`Answer 6`: `Yes` this is feasible. Well what is the `totient of n`? The totient of n is essentially the range from which we can pick our public key `e` from. We'll also use it (with e) to create our private key `d` later on. So to work out the totient we work out totient(n) = (p-1)*(q-1) So if we have p and q we should be easily able to work out totient (n).

```terminal
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO FILL IN THE MADLIB! ###
totient(n):
```

`Question 7:` totient(n)?

`Answer 7:` totient(n) = (p-1)*(q-1)
so substituting in the values we have for p and q, we get : totient(n) = (78203-1)*(79999-1) = `6256003596`

```terminal
#### TIME TO FILL IN THE MADLIB! ###
totient(n): 6256003596
YAHHH! That one was a great madlib!!!


#### NEW MADLIB ####
plaintext : 1815907181716474805136452061793917684000871911998851410864797078911161933431337632774829806207517001958179617856720738101327521552576351369691667910371502971480153619360010341709624631317220940851114914911751279825748
e : 3
n : 29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207478527881025116332742616201890576280859777513414460842754045651093593251726785499360828237897586278068419875517543013545369871704159718105354690802726645710699029936754265654381929650494383622583174075805797766685192325859982797796060391271817578087472948205626257717479858369754502615173773514087437504532994142632207906501079835037052797306690891600559321673928943158514646572885986881016569647357891598545880304236145548059520898133142087545369179876065657214225826997676844000054327141666320553082128424707948750331
##### WE'RE GONNA NEED THE FOLLOWING ####
ciphertext
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO FILL IN THE MADLIB! ###
ciphertext:
```

`Question 8:` Is it feasible to calculate the ciphertext given the plaintext and the value e and n?

`Answer 8:` Again `yes` this is feasible. RSA encryption works using just the public key values n and e. So once we have the values n and e we should be able to create the ciphertext. for RSA encryption, the $$ciphertext = plaintext ^ e mod n$$

>**Hint:** in python the easiest way to perform this calculation is to use the `pow()` function. So ciphertext = plaintext ^ e mod n would be written as `ciphertext = pow (plaintext,e,n)`

```terminal
##### WE'RE GONNA NEED THE FOLLOWING ####
ciphertext
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO FILL IN THE MADLIB! ###
ciphertext:
```

`Question 9:` Calculate the ciphertext.

`Answer 9:` We've just seen that in python code `ciphertext = pow (plaintext,e,n)` So let's just use python to do the work for us.

```python
p=815907181716474805136452061793917684000871911998851410864797078911161933431337632774829806207517001958179617856720738101327521552576351369691667910371502971480153619360010341709624631317220940851114914911751279825748
e=3
n=29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207478527881025116332742616201890576280859777513414460842754045651093593251726785499360828237897586278068419875517543013545369871704159718105354690802726645710699029936754265654381929650494383622583174075805797766685192325859982797796060391271817578087472948205626257717479858369754502615173773514087437504532994142632207906501079835037052797306690891600559321673928943158514646572885986881016569647357891598545880304236145548059520898133142087545369179876065657214225826997676844000054327141666320553082128424707948750331

ciphertext = pow(p,e,n)
print (ciphertext)
```

```terminal
#### TIME TO FILL IN THE MADLIB! ###
ciphertext: 26722917505435451150596710555980625220524134812001687080485341361511207096550823814926607028717403343344600191255790864873639087129323153797404989216681535785492257030896045464472300400447688001563694767148451912130180323038978568872458130612657140514751874493071944456290959151981399532582347021031424096175747508579453024891862161356081561032045394147561900547733602483979861042957169820579569242714893461713308057915755735700329990893197650028440038700231719057433874201113850357283873424698585951160069976869223244147124759020366717935504226979456299659682165757462057188430539271285705680101066120475874786208053
YAHHH! That one was a great madlib!!!

#### NEW MADLIB ####
ciphertext : 107524013451079348539944510756143604203925717262185033799328445011792760545528944993719783392542163428637172323512252624567111110666168664743115203791510985709942366609626436995887781674651272233566303814979677507101168587739375699009734588985482369702634499544891509228440194615376339573685285125730286623323
e : 3
n : 27566996291508213932419371385141522859343226560050921196294761870500846140132385080994630946107675330189606021165260590147068785820203600882092467797813519434652632126061353583124063944373336654246386074125394368479677295167494332556053947231141336142392086767742035970752738056297057898704112912616565299451359791548536846025854378347423520104947907334451056339439706623069503088916316369813499705073573777577169392401411708920615574908593784282546154486446779246790294398198854547069593987224578333683144886242572837465834139561122101527973799583927411936200068176539747586449939559180772690007261562703222558103359
##### WE'RE GONNA NEED THE FOLLOWING ####
plaintext
IS THIS POSSIBLE and FEASIBLE? (Y/N):
```

`Question 10:` Is it feasible to find the plaintext given the ciphertext and the values n and e?

`Answer 10:` Hopefully you already answered `no` this is not feasible. As we've already mentioned (n,e) are commonly referred to as the public key part of RSA and we typically use those values when we perform encryption using RSA. It wouldn't make sense if these same values could be used to decrypt the ciphertext. To perform the decryption we use the private key value d with the value n.

>**Note:** Technically e and d are the opposites of each other so if someone has used their d value to perform the encryption then we would use e for the decryption. This is sometimes done, but mainly with digital signatures.

```terminal
##### WE'RE GONNA NEED THE FOLLOWING ####
plaintext
IS THIS POSSIBLE and FEASIBLE? (Y/N):n
YAHHH! That one was a great madlib!!!


#### NEW MADLIB ####
q : 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559
p : 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637
e : 65537
##### WE'RE GONNA NEED THE FOLLOWING ####
d
IS THIS POSSIBLE and FEASIBLE? (Y/N):
```

`Question 11:` Given the values for p,q,e is it feasible we can calculate the value for d?

`Answer 11:` As part of calculating e we need p and q, and to calculate d we need p, and e. Since we have all those values, 'yes' it should be feasible to calculate d.

```terminal
#### NEW MADLIB ####
q : 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559
p : 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637
e : 65537
##### WE'RE GONNA NEED THE FOLLOWING ####
d
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO FILL IN THE MADLIB! ###
d:
```

`Question 12:` Calculate d.

`Answer 12:` This is the final piece of the RSA puzzle as such. Once we have picked a value for e we need to work out the inverse of e which we call d. Both are opposites of each other so what one does the other undoes. To calculate d, we need to find a value for d such that d*e mod (p-1)*(q-1) = 1.

We could just try lots of values for d, one by one until we find a value for d that works, but this is a lot of work especially as the numbers used for real RSA can be huge. Thankfully there are a couple of shortcuts to speed it up using a fancy algorithm called the `extended Euclidean algorithm`. I won't get into all the details in this particular walk through, but if we're are going to be doing RSA challenges we need to some way to get the inverse of e (`d`). Thankfully this is such a common function that most programming languages have a built in functions that we can use todo the work for us. So have a look at the small script below which you can use yourself if needed.

```python

q = 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559
p = 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637
e = 65537

toient = (p-1)*(q-1)
d = pow(e,-1,toient)   ## assumes python version >= 3.8
print (d)
```

```terminal
##### WE'RE GONNA NEED THE FOLLOWING ####
d
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO FILL IN THE MADLIB! ###
d: 1405046269503207469140791548403639533127416416214210694972085079171787580463776820425965898174272870486015739516125786182821637006600742140682552321645503743280670839819078749092730110549881891271317396450158021688253989767145578723458252769465545504142139663476747479225923933192421405464414574786272963741656223941750084051228611576708609346787101088759062724389874160693008783334605903142528824559223515203978707969795087506678894006628296743079886244349469131831225757926844843554897638786146036869572653204735650843186722732736888918789379054050122205253165705085538743651258400390580971043144644984654914856729
YAHHH! That one was a great madlib!!!


#### NEW MADLIB ####
p : 153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433
ciphertext : 5315135537182226856134532843338546481354659841681272223692273789930341302489189252395544040217036010025492161730920090820789264419456405499853943420863961834511620167348215712366219204972198527365477630427263725627920265227612760416678425823843187407675643742844283110052895704455415142735463486037912801307917634230788549540802477270278755052542590491708620341889689884020271200598596327430790861785538107067664504281508756159305916221674161062222221931717498244841323828452111473034440447694160917521358885718436832783214139059379459896493819067235346238816701274408935126796953373891399167497687512301978797146598
e : 65537
n : 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239
##### WE'RE GONNA NEED THE FOLLOWING ####
plaintext
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO FILL IN THE MADLIB! ###
plaintext:
```

`Question 13:` Can we calculate the plaintext if we are given the ciphertext, n,e,p?

`Answer 13:` This is similar to the earlier question that asked could we calculate the plaintext but this time we've been given an extra piece of information as we now have the value for p. Since we have n and p we should be able to work out q. And if we have e,p and q, we can work out d, which would allow us to perform the decryption and hence get the plaintext.

`Question 14:` Calculate the plaintext.

`Answer 14:` OK so to perform the decryption we are ultimately going to need d. However to calculate d we first need to have e,p and q. The question gives us e and p so we need to find q.

we know `n = p * q` so `q = n / p` and once we have q. Then `d = modinv(e,toient(n))`. If we have the value for d we can perform the RSA decryption as `plaintext = ciphertext ^ d mod n`. Let's put it all into a quick python script and see what it looks like.

```python
ciphertext = 5315135537182226856134532843338546481354659841681272223692273789930341302489189252395544040217036010025492161730920090820789264419456405499853943420863961834511620167348215712366219204972198527365477630427263725627920265227612760416678425823843187407675643742844283110052895704455415142735463486037912801307917634230788549540802477270278755052542590491708620341889689884020271200598596327430790861785538107067664504281508756159305916221674161062222221931717498244841323828452111473034440447694160917521358885718436832783214139059379459896493819067235346238816701274408935126796953373891399167497687512301978797146598
p = 153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433
e = 65537
n = 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239

q = n // p
toient = (p-1)*(q-1)
d = pow(e,-1,toient)
plaintext = pow(ciphertext,d,n)
print (plaintext)
```

```terminal
##### WE'RE GONNA NEED THE FOLLOWING ####
plaintext
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO FILL IN THE MADLIB! ###
plaintext: 240109877286251840533272915662757983981706320845661471802585807564915966910384301849411666983334013
YAHHH! That one was a great madlib!!!

If you convert the last plaintext to a hex number, then ascii, you'll find what you're searching for ;)

```

`Question 15:` Finally it looks like we've reach the end of this challenge we have one last step before we can get the flag. We just need to convert the plaintext value we calculated into hex and then into ascii to reveal our flag.

`Answer 15:` Again we'll use a small piece of python code to perform the calculations for us.

```python
flag = bytes.fromhex(hex(plaintext)[2:])

print (flag.decode())
```

And finally we're done and our hard earned flag is revealed. `picoCTF{d0_u_kn0w_th3_w@y_2_RS@_5d383e10}`

### Flag

`picoCTF{d0_u_kn0w_th3_w@y_2_RS@_5d383e10}`

### Scripted Solution

We introduced a lot of different code snippets during this challenge, below you can find the full source code listing. This is just the basic python code needed to perform the calculations for each question.

```python
#!/usr/bin/env python3

## Walk through solution pcioCTF 2018 - rsa madlib
## AlphaChaos.net
##-------------------------------------------------------------------------------

## Question 1
## Is it feasible to find n?
## yes, n = p * q

## Question 2
p = 93187
q = 94603
n = p * q
print ('n = ',n)

## Question 3
## Is it feasible to find q?
## yes,  q = n / q

## Question 4
n = 6315400919
p = 81203
q = n // p          ## use // for rounded integer division
print ('q = ',q)

## Question 5
## Given e,n can we work out p,q
## no, this is not feasible

## Question 6
## is it feasible to calculate totient(n)
## yes, totient(n) = (p-1)*(q-1)

## Question 7
q = 78203
p = 79999
totient_n = (p-1)*(q-1)
print ('toient(n) = ',totient_n)

## Question 8
## Given plaintext, e and n can we calculate ciphertext
## yes, ciphertext = plaintext ^ e mod n

## Question 9
plaintext = 1815907181716474805136452061793917684000871911998851410864797078911161933431337632774829806207517001958179617856720738101327521552576351369691667910371502971480153619360010341709624631317220940851114914911751279825748
e = 3
n = 29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207478527881025116332742616201890576280859777513414460842754045651093593251726785499360828237897586278068419875517543013545369871704159718105354690802726645710699029936754265654381929650494383622583174075805797766685192325859982797796060391271817578087472948205626257717479858369754502615173773514087437504532994142632207906501079835037052797306690891600559321673928943158514646572885986881016569647357891598545880304236145548059520898133142087545369179876065657214225826997676844000054327141666320553082128424707948750331
ciphertext = pow(plaintext,e,n)
print ('ciphertext = ',ciphertext)

## Question 10
## Given ciphertext, e, n is is feasible to calculate plaintext
## no, this is not feasible

## Question 11
## Given p,q,e is it feasible to calculate d
## yes, d = mod_inverse(e,toient(n))

## Question 12
q = 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559
p = 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637
e = 65537
toient = (p-1)*(q-1)
d = pow(e,-1,toient)
print ('d = ',d)

## Question 13
## Given ciphertext, p, e and n is it feasible to calculate plaintext
## yes, plaintext = ciphertext^d mod n, d = mod_inverse(e,toient(n)), q = n / p

## Question 14
ciphertext = 5315135537182226856134532843338546481354659841681272223692273789930341302489189252395544040217036010025492161730920090820789264419456405499853943420863961834511620167348215712366219204972198527365477630427263725627920265227612760416678425823843187407675643742844283110052895704455415142735463486037912801307917634230788549540802477270278755052542590491708620341889689884020271200598596327430790861785538107067664504281508756159305916221674161062222221931717498244841323828452111473034440447694160917521358885718436832783214139059379459896493819067235346238816701274408935126796953373891399167497687512301978797146598
p = 153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433
e = 65537
n = 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239
q = n // p
toient = (p-1)*(q-1)
d =  pow(e,-1,toient)
plaintext = pow(ciphertext,d,n)
print ('plaintext = ',plaintext)

## Question 15
## convert last plaintext to a hex number, then ascii

flag = bytes.fromhex(hex(plaintext)[2:])
print (flag.decode())
```
