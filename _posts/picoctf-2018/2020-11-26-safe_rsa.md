---
title: PicoCTF 2018 - Safe RSA
author: AlphaChaos
date: 2020-11-26 15:00:00 +0000
categories: [PicoCTF_2018]
tags: [basics, picoctf, rsa,tutorial, intermediate]     # TAG names should always be lowercase
---

### Challenge Description

> Now that you know about RSA can you help us decrypt this [ciphertext](../../assets/challs/picoctf2018/safe_rsa_ciphertext.txt)? We don't have the decryption key but something about those values looks funky..

### Challenge Hint

> [RSA tutorial](https://en.wikipedia.org/wiki/RSA_(cryptosystem))
> Hmmm that e value looks kinda small right?  
> These are some really big numbers.. Make sure you're using functions that don't lose any precision!

### Challenge Analysis

So let's look at what information we are given in the challenge.  

This challenge gives us some ciphertext and the RSA public key values (n,e). From the [last challenge on RSA](2020-11-26-rsa_madlibs.md) we learnt that normally given just the public key values (n,e) we shouldn't be able to decrypt the ciphertext? So what's going on here?

There are a number of different common attacks or weaknesses against RSA, that can sometimes be performed if certain conditions are true. So lets see what other info we have for this challenge.

The hints for the challenge talk about really big numbers but also about really small values for e. Let's look at the small e value first. There are a number of attacks against RSA when e is very small, but a small e value on it's own is not always a problem. We also have a very large n value, which is usually a good thing and harder to break, but a big n and small e together can be a problem especially if the plaintext message is also relatively short.

Let's see why these values can cause a problem:

To encrypt a message with RSA we calculate the `ciphertext = plaintext ^ e mod n`. For RSA the plaintext is always represented as a number, but what happens if `plaintext ^ e` is smaller than n? Which is more likely to happen if e is small and n is big or the message itself is short.

So in these scenarios the `mod n` part of the calculation basically does nothing. For example if we did 2 ^ 3 mod 29, we'd get 8 mod 29, the mod 29 part would be redundant and we'd basically be left with just 2 ^ 3 or 8. The same has happened here and it's a common enough RSA ctf style challenge.

```common
Summary
--------------------------------
ciphertext = long section of ciphertext
public key values = n,e
```

### Challenge Solution

To solve this challenge we are assuming that the original plaintext ^ e is < mod n. So the ciphertext that we have is essentially the plaintext ^ 3. So to recover the original plaintext we need to get the cubed root (inverse of ^3) of the ciphertext.

Calculating the cubed root however can be tricky. In python we could do something like `ciphertext ** (1. / 3)` or `pow(ciphertext,1/3)` to compute the (floating-point) cube root of x. However both of these methods are prone to rounding and precision errors especially when dealing with big numbers, so are best to be avoided.

For larger numbers, one way to do it is to do a binary search for the true cube root using integers only to preserve precision:

```python
## can be used to get any root not just cubed root.
def kth_root(n,k):
    lo,hi = 0,n #lower bound, upper bound
    while lo < hi:
        mid = (lo+hi)//2
        if pow(mid,k) < n: lo = mid+1
        else: hi = mid
    return lo

c = 2205316413931134031046440767620541984801091216351222789180967130585669043554866325905770867150377611820746759815247778516899403229047066700396787852388511389893043279713280998235746440322483431305358901578692935378439077796777060321410661

plaintext = find_kth_root(c,3)

## Once we get the cubed root,
## We still need to convert the int into hex and then ascii to get the flag.
flag = bytes.fromhex(hex(plaintext)[2:])
print (flag.decode())
```

### Flag

`picoCTF{e_w4y_t00_sm411_a5b5aaac}`
