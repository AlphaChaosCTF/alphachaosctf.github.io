---
title: PicoCTF 2018 - SpyFi
author: AlphaChaos
date: 2020-11-28 12:45:00 +0000
categories: [PicoCTF_2018]
tags: [picoctf, aes-ecb, tutorial, chosen-plaintext-attack, intermediate]     # TAG names should always be lowercase
---

### Challenge Description

> James Brahm, James Bond's less-franchised cousin, has left his secure communication with HQ running, but we couldn't find a way to steal his agent identification code. Can you? Connect with `nc 2018shell.picoctf.com 34490`.  
[Source](../../assets/challs/picoctf2018/spy_terminal_no_flag.py).

### Challenge Hint

> What mode is being used?

### Challenge Analysis

So let's look at what information we are given in the challenge.  

OK examining the code and using the hint provided we can see that the program is using `AES.MODE_ECB`. ECB mode has some weaknesses that we can potentially exploit.

> **Hint:** If you are not familiar with ECB block mode you can find out mode details [here](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_(ECB)).

AES is a block cipher, so any message that we might want to encrypt is first divided up into fixed sized blocks, the initial message is padded if needed so all blocks are the same size. 

So for example if we wanted to encrypt the message `This is some random message` we would split the message into blocks of 16 bytes, padding the last message to fill the second block.  
` block 1 = "This is some ran" `  
` block 2 = "dom0000000000000" `

How our cipher links or chains these different blocks together during the encryption process is know as the block cipher mode of operation, and ECB is one of many possible options. Thankfully, It's also one of the simplest modes to understand.

![ECB](../../assets/challs/picoctf2018/ECB_encryption.png){:class="normal"}

As we can see from the diagram with ECB, each block is encrypted independently. So if two blocks contain the same plaintext they would encrypt to the same identical ciphertext. This property will be the key to solving this challenge successfully.

The challenge allows us to submit some plaintext and see the corresponding ciphertext. This means we have the ability to perform a `chosen-plaintext attack (CPA)`.  

So let's look at the script details to see how we might be able to perform a CPA for this challenge.

```python
message = """Agent,
Greetings. My situation report is as follows:
{0}
My agent identifying code is: {1}.
Down with the Soviets,
006
""".format( sitrep, agent_code )
```

So whatever message (the sitrep) we pass to the program is being inserted into this fixed format, which includes the agent code (the flag in this case) and some other report formatting. This final message will be split into fixed sizes blocks of 16 and each encrypted separately.

So if we submitted the sitrep message of 'AAAAAAAAAAAAAAAA' (A*16) and we assume that the agent code is in the normal flag format, something like `picoCTF{some_message}` our final message for encryption would look like:  

`[01] Agent,\nGreetings `  
`[02] . My situation r  `  
`[03] eport is as foll  `  
`[04] ows:\nAAAAAAAAAAA `  
`[05] AAAAA\nMy agent i `  
`[06] dentifying code   `  
`[07] is: picoCTF{some  `  
`[08] e_message}.\nDown  `  
`[09]  with the Soviet `  
`[10] s,\n0060000000000 `  

Now to take advantage of CPA and ECB mode we need to be smart about how we craft the message that we submit. Crafting the message contents and deciding the correct length is the trick to solving the challenge. What we want to try and do is create two blocks that are near identical, so we can compare them. We can then confirm that our layout etc. is correct.

If we imagine that we are trying to insert an extra block between blocks [04] and [05] above, this is going to be the block we use for checking against any other blocks. So if we inserted a block identical to block [03] for example then when we compare the output ciphertext for block [03] and our newly insert block [05] they should be identical

`[01] Agent,\nGreetings `  
`[02] . My situation r  `  
`[03] eport is as foll  <-- output ciphertext should match block [05] `  
`[04] ows:\nAAAAAAAAAAA `  
`[05] eport is as foll  <-- output ciphertext should match block [03] `  
`[06] AAAAA\nMy agent i `  
`[07] dentifying code   `  
`[08] is: picoCTF{some  `  
`[09] e_message}.\nDown `  
`[10]  with the Soviet  `  
`[11] s,\n0060000000000 `  

But how exactly do we go about inserting this extra block into the encryption process? We only have control of one element and that is the sitrep message. By correctly working out the lengths of the other blocks we should be able to work out were to insert our comparison block. In this case you should be able to see we will need 11 characters to fill block [04], after which we can insert our comparison block and check it against any of the other block we want to confirm.

So our sitrep message now consist of 11 filler characters to complete block [04] + some 16 character comparison block + 5 additional spacing characters.  

sitrep message:  
`AAAAAAAAAAAeport is as follAAAAA`  
`filler (A*11) + comparison block (16) + spacing (A*5)`

The goal is to recover the agent code or the flag, so we will want to use our comparison block to compare against a block that has some of the flag and keep guessing until the ciphertext outputs match. Rather than trying to guess multiple characters of the flag at a time it would be much more efficient if we could just check one character at a time, and work our way through the flag message.

The trick this time is to try and align the blocks after our inserted sitrep message so that the start of the flag message is aligned in the last position of some block. We can achieve this by easily changing the length of our spacing so move the flag part into the correct position.

`[01] Agent,\nGreetings `  
`[02] . My situation r  `  
`[03] eport is as foll   `  
`[04] ows:\nAAAAAAAAAAA `  
`[05] fying code is: p  <-- output ciphertext should match block [09] `  
`[06] AAAAAAAAAAAAAAAA `  
`[07] AAAAAAAAAAAAAAAA  <-- we can adjust the spacing length  `  
`[08] \nMy agent identi `  
`[09] fying code is: p  <-- output ciphertext should match block [05]`  
`[10] icoCTF{somee_mes `  
`[11] sage}.\nDown wit`  

So we can see by adjusting the number of characters we use in the our spacing we can force the last character of block [09] to contain the start of our flag.

By brute forcing the last character each time, and adjusting the spacing each time, So the next character of the flag message appears in the last position, we can again brute force the flag one character at a time.





### Challenge Solution

To solve this challenge we are assuming that the original plaintext ^ e is < mod n. So the ciphertext that we have is essentially the plaintext ^ 3. So to recover the original plaintext we need to get the cubed root (inverse of ^3) of the ciphertext.

Calculating the cubed root however can be tricky. In python we could do something like `ciphertext ** (1. / 3)` or `pow(ciphertext,1/3)` to compute the (floating-point) cube root of x. However both of these methods are prone to rounding and precision errors especially when dealing with big numbers, so are best to be avoided.

For larger numbers, one way to do it is to do a binary search for the true cube root using integers only to preserve precision:

```python
## can be used to get any root not just cubed root.
def kth_root(n,k):
    lo,hi = 0,n #lower bound, upper bound
    while lo < hi:
        mid = (lo+hi)//2
        if pow(mid,k) < n: lo = mid+1
        else: hi = mid
    return lo

c = 2205316413931134031046440767620541984801091216351222789180967130585669043554866325905770867150377611820746759815247778516899403229047066700396787852388511389893043279713280998235746440322483431305358901578692935378439077796777060321410661

plaintext = find_kth_root(c,3)

## Once we get the cubed root,
## We still need to convert the int into hex and then ascii to get the flag.
flag = bytes.fromhex(hex(plaintext)[2:])
print (flag.decode())
```

### Flag

`picoCTF{e_w4y_t00_sm411_a5b5aaac}`
