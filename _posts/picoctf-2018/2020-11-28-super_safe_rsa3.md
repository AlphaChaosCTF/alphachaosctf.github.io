---
title: PicoCTF 2018 - Super Safe RSA 3
author: AlphaChaos
date: 2020-11-28 12:15:00 +0000
categories: [PicoCTF_2018]
tags: [basics, picoctf, rsa, factoring,tutorial, intermediate]     # TAG names should always be lowercase
---

### Challenge Description

> The more primes, the safer.. right.?.? Connect with nc 2018shell.picoctf.com 21287.

### Challenge Hint

> How would you find d if there are more than 2 prime factors of n?

### Challenge Analysis

So let's look at what information we are given in the challenge.  

```terminal
$ nc 2018shell.picoctf.com 21287
c: 1826837827075822799519875974348001547406644576216072985913850356359916349198336584504870680034902979154605249599432858510272435056062275319804429833923877800965696848057373845359668807034608831624580082651924704512749010225445666634007866609310974286043167768842281766236815604737077458841753718054696227
n: 16981155391271523346120417799076788394533867348232165061566411944696442507551068944024752981481928866920076078430437927526968133714768495986847792417230579935392777360618767664900052254743745936064895539067147189021483784993569019849855124780846435462020484836113631579215513645546355153531459035251856271
e: 65537

```

The challenge description and hint all suggest multi prime rsa. Since we're not given any of the factors in the challenge we can assume we have to factor n. So a similar approach to the earlier [Super Safe RSA Challenge](2020-11-26-super_safe_rsa.md)

Assuming we can get the factors of n, the next challenge will be to calculate d. So the challenge appears to checking if we understand how d is calculated. d is normally the modular inverse of (e,toient(n)) for multi prime RSA this doesn't change. What does change however is how we calculate toient(n).

With 2 prime factors we normally calculate toient(n) = (p-1)*(q-1), but if we have more factors the toient calculation becomes (a-1)*(b-1)*(c-1).. etc. so the product of all the (prime factors -1).

### Challenge Solution

Out first issue is getting the factors of n, jumping onto [factordb.com](http://factordb.com/) we quickly get all of the factors.

>**Note:** make sure you get the prime factors

factors = [2158604873,2214029071,2277018697,2343314189,2746184767,2748597559,2750963261,2908544407,2937064129,2945919187,2975397287,3010471787,3034871293,3192950807,3220845827,3266220247,3332957387,3390978599,3407888941,3486331061,3495756961,3602229221,3653423443,3715262609,3735356657,3742522621,3838126393,4030261789,4062865451,4067447977,4124468729,4125419159]

So we should be able to decrypt as normal once we tweak how we calculate toient(n)

```python
c= 1826837827075822799519875974348001547406644576216072985913850356359916349198336584504870680034902979154605249599432858510272435056062275319804429833923877800965696848057373845359668807034608831624580082651924704512749010225445666634007866609310974286043167768842281766236815604737077458841753718054696227
n= 16981155391271523346120417799076788394533867348232165061566411944696442507551068944024752981481928866920076078430437927526968133714768495986847792417230579935392777360618767664900052254743745936064895539067147189021483784993569019849855124780846435462020484836113631579215513645546355153531459035251856271
e= 65537

factors = [2158604873,2214029071,2277018697,2343314189,2746184767,2748597559,2750963261,2908544407,2937064129,2945919187,2975397287,3010471787,3034871293,3192950807,3220845827,3266220247,3332957387,3390978599,3407888941,3486331061,3495756961,3602229221,3653423443,3715262609,3735356657,3742522621,3838126393,4030261789,4062865451,4067447977,4124468729,4125419159]

toient=1

for f in factors:
    toient = toient*(f-1)

d = pow(e,-1,toient)

plaintext = pow(c,d,n)

flag = bytes.fromhex(hex(plaintext)[2:])
print (flag.decode())
```

### Flag

`picoCTF{p_&_q_n0_r_$_t!!_1297651}`
